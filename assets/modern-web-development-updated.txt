# Modern Web Development Rules - Updated for IGCSE Music Study Hub

## Core Principles (APPLICABLE)
- Write concise, technical responses with accurate TypeScript examples.
- Use functional, declarative programming. Avoid classes.
- Prefer iteration and modularization over duplication.
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).
- Use lowercase with dashes for directories (e.g., components/auth-wizard).
- Favor named exports for components.
- Use the Receive an Object, Return an Object (RORO) pattern.

## JavaScript/TypeScript (APPLICABLE)
- Use "function" keyword for pure functions. Omit semicolons.
- Use TypeScript for all code. Prefer interfaces over types.
- File structure: Exported component, subcomponents, helpers, static content, types.
- Avoid unnecessary curly braces in conditional statements.
- For single-line statements in conditionals, omit curly braces.
- Use concise, one-line syntax for simple conditional statements (e.g., if (condition) doSomething()).

## Error Handling and Validation (HIGH PRIORITY FOR IGCSE PROJECT)
- Prioritize error handling and edge cases:
  - Handle errors and edge cases at the beginning of functions.
  - Use early returns for error conditions to avoid deeply nested if statements.
  - Place the happy path last in the function for improved readability.
  - Avoid unnecessary else statements; use if-return pattern instead.
  - Use guard clauses to handle preconditions and invalid states early.
  - Implement proper error logging and user-friendly error messages.
  - Consider using custom error types or error factories for consistent error handling.

## IGCSE-Specific Error Handling Additions:
- Add React Error Boundaries for quiz components and audio players
- Implement graceful fallbacks for audio/MIDI loading failures
- Add user-friendly error messages for educational content loading
- Handle network failures for external resources (audio files, images)
- Validate quiz answers and provide immediate feedback
- Add error recovery for language switching failures

## React/Vite (ADAPTED FOR VITE INSTEAD OF NEXT.JS)
- Use functional components and TypeScript interfaces.
- Use declarative JSX.
- Use function, not const, for components.
- Use Tailwind CSS for components and styling (ALREADY IMPLEMENTED).
- Implement responsive design with Tailwind CSS (ALREADY IMPLEMENTED).
- Use mobile-first approach for responsive design (ALREADY IMPLEMENTED).
- Place static content and interfaces at file end.
- Use content variables for static content outside render functions.
- Minimize 'useEffect', and 'setState'. Favor React functional patterns.
- Use Zod for form validation (RECOMMENDED FOR QUIZ COMPONENTS).
- Wrap components in Suspense with fallback for better UX.
- Use dynamic loading for non-critical components.
- Optimize images: WebP format, size data, lazy loading.
- Model expected errors as return values: Avoid using try/catch for expected errors.
- Use error boundaries for unexpected errors: Implement error boundaries for quiz and audio components.
- Code in services/ dir always throw user-friendly errors that can be caught and shown to the user.

## IGCSE-Specific React Patterns:
- Quiz state management with proper error handling
- Audio player state management with loading/error states
- Multi-language content switching with fallbacks
- Progress tracking for educational content
- Responsive design optimized for educational content consumption

## Vite-Specific Optimizations (REPLACES NEXT.JS RULES):
- Use Vite's dynamic imports: import('./Component').then(module => module.default)
- Implement proper chunk splitting in vite.config.ts
- Use Vite's environment variables: import.meta.env.VITE_API_KEY
- Leverage Vite's fast HMR for development
- Use Vite's asset handling for audio/MIDI files
- Configure proper build optimizations for educational content

## Performance Optimization (HIGH PRIORITY)
- Implement lazy loading for large educational content sections
- Use React.Suspense for code splitting
- Optimize audio/MIDI file loading with proper caching
- Implement virtual scrolling for long content lists
- Use proper memoization for expensive calculations (music theory)
- Optimize bundle size with proper tree shaking

## Accessibility (HIGH PRIORITY FOR EDUCATIONAL CONTENT)
- Ensure all interactive elements are keyboard navigable
- Implement proper ARIA labels for quiz components and audio players
- Ensure color contrast ratios meet WCAG standards for educational content
- Add screen reader support for musical notation and symbols
- Implement proper focus management for quiz navigation
- Add audio descriptions for visual musical content where possible

## Educational Content Specific Patterns:
- Quiz component error handling and validation
- Audio player state management with proper loading states
- Multi-language content organization and switching
- Progress indication for learning modules
- Responsive design for musical notation and diagrams
- Proper handling of musical symbols and Unicode characters

## Testing (RECOMMENDED FOR FUTURE IMPLEMENTATION)
- Implement unit tests for utility functions and quiz logic
- Use integration tests for quiz components and audio players
- Implement end-to-end tests for critical learning flows
- Test accessibility features with screen readers
- Test multi-language functionality
- Test audio/MIDI playback across different browsers

## Key Conventions (ADAPTED)
1. Rely on React Router for state changes and routing (INSTEAD OF NEXT.JS APP ROUTER).
2. Prioritize Web Vitals (LCP, CLS, FID) for educational content.
3. Minimize 'use client' usage (NOT APPLICABLE - USING VITE).
4. Use proper component structure for educational content.
5. Use Vite commands for development and deployment tasks.
6. Adhere to educational content accessibility standards.

## Naming Conventions (APPLICABLE)
- Booleans: Use auxiliary verbs such as 'does', 'has', 'is', and 'should' (e.g., isDisabled, hasError).
- Filenames: Use lowercase with dash separators (e.g., quiz-component.tsx).
- File extensions: Use .config.ts, .test.ts, .context.tsx, .type.ts, .hook.ts as appropriate.

## Component Structure (APPLICABLE)
- Break down components into smaller parts with minimal props.
- Suggest micro folder structure for components.
- Use composition to build complex components.
- Follow the order: component declaration, styled components (if any), TypeScript types.

## Data Management (ADAPTED FOR STATIC CONTENT)
- Use React state and context for client-side state management.
- Implement proper loading states for educational content.
- Use local storage for user progress and preferences.
- Implement proper caching for audio and educational resources.

## Styling (ALREADY IMPLEMENTED)
- Use Tailwind CSS for styling, following the Utility First approach.
- Utilize custom CSS classes for complex educational content layouts.
- Ensure responsive design works well for educational content consumption.

## Documentation (HIGH PRIORITY)
- Provide clear and concise comments for complex educational logic.
- Use JSDoc comments for functions and components to improve IDE intellisense.
- Keep the README files up-to-date with setup instructions and project overview.
- Document educational content structure and quiz formats.
- Document audio/MIDI integration patterns.

## FUTURE IMPLEMENTATION RULES (KEEP FOR LATER):

### AI SDK (FOR FUTURE CHATBOT ENHANCEMENTS)
- Use the Vercel AI SDK UI for implementing streaming chat UI.
- Use the Vercel AI SDK Core to interact with language models.
- Use the Vercel AI SDK RSC and Stream Helpers to stream and help with the generations.
- Implement proper error handling for AI responses and model switching.
- Implement fallback mechanisms for when an AI model is unavailable.
- Handle rate limiting and quota exceeded scenarios gracefully.
- Provide clear error messages to users when AI interactions fail.
- Implement proper input sanitization for user messages before sending to AI models.
- Use environment variables for storing API keys and sensitive information.

### Next.js (FOR FUTURE MIGRATION CONSIDERATION)
- Use functional components and TypeScript interfaces.
- Use declarative JSX.
- Use function, not const, for components.
- Use Shadcn UI, Radix, and Tailwind CSS for components and styling.
- Implement responsive design with Tailwind CSS.
- Use mobile-first approach for responsive design.
- Place static content and interfaces at file end.
- Use content variables for static content outside render functions.
- Minimize 'use client', 'useEffect', and 'setState'. Favor React Server Components (RSC).
- Use Zod for form validation.
- Wrap client components in Suspense with fallback.
- Use dynamic loading for non-critical components.
- Optimize images: WebP format, size data, lazy loading.
- Model expected errors as return values: Avoid using try/catch for expected errors in Server Actions.
- Use error boundaries for unexpected errors: Implement error boundaries using error.tsx and global-error.tsx files.
- Use useActionState with react-hook-form for form validation.
- Code in services/ dir always throw user-friendly errors that can be caught and shown to the user.
- Use next-safe-action for all server actions.
- Implement type-safe server actions with proper validation.
- Handle errors gracefully and return appropriate responses.

### Supabase and GraphQL (FOR FUTURE BACKEND INTEGRATION)
- Use the Supabase client for database interactions and real-time subscriptions.
- Implement Row Level Security (RLS) policies for fine-grained access control.
- Use Supabase Auth for user authentication and management.
- Leverage Supabase Storage for file uploads and management.
- Use Supabase Edge Functions for serverless API endpoints when needed.
- Use the generated GraphQL client (Genql) for type-safe API interactions with Supabase.
- Optimize GraphQL queries to fetch only necessary data.
- Use Genql queries for fetching large datasets efficiently.
- Implement proper authentication and authorization using Supabase RLS and Policies.

### Data Fetching and State Management (FOR FUTURE BACKEND)
- Use React Server Components for data fetching when possible.
- Implement the preload pattern to prevent waterfalls.
- Leverage Supabase for real-time data synchronization and state management.
- Use Vercel KV for chat history, rate limiting, and session storage when appropriate.

## PRIORITY IMPLEMENTATION ORDER FOR IGCSE PROJECT:

### Phase 1 (High Priority - Immediate):
1. Implement React Error Boundaries for quiz and audio components
2. Add Zod validation for quiz submissions and form inputs
3. Improve error handling in audio/MIDI players
4. Add proper loading states and user feedback
5. Implement accessibility improvements (ARIA labels, keyboard navigation)

### Phase 2 (Medium Priority - Next Sprint):
1. Add Suspense boundaries with proper fallbacks
2. Implement lazy loading for large content sections
3. Optimize image loading (WebP, lazy loading)
4. Add proper JSDoc documentation
5. Implement user progress tracking with local storage

### Phase 3 (Low Priority - Future Enhancement):
1. Add comprehensive testing suite
2. Implement advanced performance optimizations
3. Consider migration to Next.js if server-side features are needed
4. Add backend integration with Supabase if user accounts are needed
5. Implement AI-powered features for enhanced learning

Refer to React documentation for best practices in functional components and hooks, Vite documentation for build optimization, and Web Accessibility Guidelines for educational content accessibility standards.